import torch, cv2
import sys, os
import numpy as np
from stable_diffusion.ldm.util_ddim import load_img as loads
from basicsr import img2tensor, tensor2img
from einops import repeat
from tqdm import tqdm
from segment_anything import sam_model_registry, SamAutomaticMaskGenerator, SamPredictor


def get_masked_Image(seg: list = None, no_color: bool = False):
    assert seg != None
    # seq_choice = kwargs['seq_choice'] if 'seq_choice' in kwargs.keys() else [1] * len(seg)
    if len(seg) == 0:
        return
    sorted_seg = sorted(seg, key=(lambda x: x['area']), reverse=True)
    img = np.ones((sorted_seg[0]['segmentation'].shape[0], sorted_seg[0]['segmentation'].shape[1], 4))
    img[:,:,3] = 0

    for i in range(len(sorted_seg)):
        m = sorted_seg[i]['segmentation']
        # print('seg shape: ', ann['segmentation'].shape)
        color_mask = np.concatenate([[0, 0, 0] if no_color else np.random.random(3), [0.35]])

        img[m] = color_mask

    # mask_vector = img
    # img = Image.fromarray((img * 255).astype(np.uint8))
    # img = img.convert('RGB')

    return img


# Training dataset: part of COCO, and other random generated by sd.
# Considering some little differences between generated and ground truth contributions

class DataCreator():
    def __init__(self, encoder: any = None, sam: any = None, image_folder: any = None, batch_size: int = 1):
        assert isinstance(image_folder, list) or isinstance(image_folder, str), 'path error when getting DataCreator initialized'
        self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        self.path = image_folder if isinstance(image_folder, list) else [image_folder]
        self.latent_encoder = encoder.to(self.device)
        self.sam = sam

        """
            Before DataCreator Declaration:
                sam = sam_model_registry[args.sam_type](checkpoint=args.sam_ckpt)
                sam.to(device=device)
                mask_generator = SamAutomaticMaskGenerator(sam)
                masks = mask_generator.generate(np_image)
            
            Input:
                sam = masks
            
        """

        self.batch_size = batch_size
        self.seg_list = self.latent_list = []
        self.data_dict_list = []         # [dict]

    def make_data(self, Type: str = None):
        assert Type != None
        for i in range(len(self.path)):
            folder = self.path[i]
            dir = os.listdir(folder)
            iter_ = tqdm(dir, desc=f'Cal {Type} Image in Folder: [{i}|{len(self.path)}]', total=len(dir))
            for j, file in enumerate(iter_):
                if file.endswith('.png') and file.endswith('.jpg'):
                    file = os.path.join(folder, file)  # absolute file path
                    image, _ = loads(opt=None, path=file)
                    if Type == 'Latent':
                        image = repeat(image, "1 ... -> b ...", b=self.batch_size)
                        image = image.to(self.device)
                        self.latent_list.append(self.latent_encoder(image).mode())
                    elif Type == 'SAM':
                        np_image = tensor2img(image)
                        masks = self.sam(np_image)
                        seg = get_masked_Image((masks))
                        if not isinstance(seg, torch.tensor):
                            seg = img2tensor(seg)
                        self.seg_list.append(self.latent_encoder(seg).mode())
                    else:
                        raise NotImplementedError('Type Unrecognized')
                else:
                    continue
        return

    def MakeData(self):
        self.make_data("Laten")
        self.make_data("SAM")
        assert len(self.seg_list) == len(self.latent_list), 'error occurred when making data -> make'
        self.data_dict_list = [ {'Latent':self.latent_list[i], 'SAM': self.seg_list[i]} for i in range(len(self.seg_list))]

    def __len__(self):
        assert len(self.seg_list) == len(self.latent_list), 'error occurred when making data -> len'
        return len(self.seg_list)

    def __getitem__(self, item):
        i = self.data_dict_list[item]
        assert i['Latent'].sahpe == i['SAM'].shape, 'Here'
        return i